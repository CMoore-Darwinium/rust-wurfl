/* automatically generated by rust-bindgen 0.58.1 */

pub const _TIME_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 31;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __LONG_DOUBLE_USES_FLOAT128: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const _BITS_TIME_H: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const __TIMESIZE: u32 = 64;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const CLOCK_REALTIME: u32 = 0;
pub const CLOCK_MONOTONIC: u32 = 1;
pub const CLOCK_PROCESS_CPUTIME_ID: u32 = 2;
pub const CLOCK_THREAD_CPUTIME_ID: u32 = 3;
pub const CLOCK_MONOTONIC_RAW: u32 = 4;
pub const CLOCK_REALTIME_COARSE: u32 = 5;
pub const CLOCK_MONOTONIC_COARSE: u32 = 6;
pub const CLOCK_BOOTTIME: u32 = 7;
pub const CLOCK_REALTIME_ALARM: u32 = 8;
pub const CLOCK_BOOTTIME_ALARM: u32 = 9;
pub const CLOCK_TAI: u32 = 11;
pub const TIMER_ABSTIME: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __struct_tm_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const __clockid_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const __itimerspec_defined: u32 = 1;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const TIME_UTC: u32 = 1;
pub type size_t = ::std::os::raw::c_ulong;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__fsid_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type clock_t = __clock_t;
pub type time_t = __time_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
    assert_eq!(
        ::std::mem::size_of::<tm>(),
        56usize,
        concat!("Size of: ", stringify!(tm))
    );
    assert_eq!(
        ::std::mem::align_of::<tm>(),
        8usize,
        concat!("Alignment of ", stringify!(tm))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_min as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_hour as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_hour)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_mday as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_mon as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mon)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_year as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_year)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_wday as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_wday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_yday as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_yday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_isdst as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_isdst)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_gmtoff as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_gmtoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_zone as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_zone)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
pub type clockid_t = __clockid_t;
pub type timer_t = __timer_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[test]
fn bindgen_test_layout_itimerspec() {
    assert_eq!(
        ::std::mem::size_of::<itimerspec>(),
        32usize,
        concat!("Size of: ", stringify!(itimerspec))
    );
    assert_eq!(
        ::std::mem::align_of::<itimerspec>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerspec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<itimerspec>())).it_interval as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<itimerspec>())).it_value as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigevent {
    _unused: [u8; 0],
}
pub type pid_t = __pid_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    assert_eq!(
        ::std::mem::size_of::<__locale_struct>(),
        232usize,
        concat!("Size of: ", stringify!(__locale_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__locale_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__locale_struct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__locales as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__locales)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_b as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_b)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_tolower as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_tolower)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_toupper as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_toupper)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__names as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__names)
        )
    );
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn time(__timer: *mut time_t) -> time_t;
}
extern "C" {
    pub fn difftime(__time1: time_t, __time0: time_t) -> f64;
}
extern "C" {
    pub fn mktime(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn strftime(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: size_t,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
    ) -> size_t;
}
extern "C" {
    pub fn strftime_l(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: size_t,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
        __loc: locale_t,
    ) -> size_t;
}
#[doc = "!< no error"]
pub const wurfl_error_WURFL_OK: wurfl_error = 0;
#[doc = "!< handle passed to the function is invalid"]
pub const wurfl_error_WURFL_ERROR_INVALID_HANDLE: wurfl_error = 1;
#[doc = "!< wurfl_load has already been invoked on the specific wurfl_handle"]
pub const wurfl_error_WURFL_ERROR_ALREADY_LOAD: wurfl_error = 2;
#[doc = "!< file not found during wurfl_load or remote data file update"]
pub const wurfl_error_WURFL_ERROR_FILE_NOT_FOUND: wurfl_error = 3;
#[doc = "!< unexpected end of file or parsing error during wurfl_load"]
pub const wurfl_error_WURFL_ERROR_UNEXPECTED_END_OF_FILE: wurfl_error = 4;
#[doc = "!< error reading stream during wurfl_load or updater accessing local updated data file"]
pub const wurfl_error_WURFL_ERROR_INPUT_OUTPUT_FAILURE: wurfl_error = 5;
#[doc = "!< specified device is missing"]
pub const wurfl_error_WURFL_ERROR_DEVICE_NOT_FOUND: wurfl_error = 6;
#[doc = "!< specified capability is missing"]
pub const wurfl_error_WURFL_ERROR_CAPABILITY_NOT_FOUND: wurfl_error = 7;
#[doc = "!< invalid capability value"]
pub const wurfl_error_WURFL_ERROR_INVALID_CAPABILITY_VALUE: wurfl_error = 8;
#[doc = "!< specified virtual capability is missing"]
pub const wurfl_error_WURFL_ERROR_VIRTUAL_CAPABILITY_NOT_FOUND: wurfl_error = 9;
#[doc = "!< specified capability is missing"]
pub const wurfl_error_WURFL_ERROR_CANT_LOAD_CAPABILITY_NOT_FOUND: wurfl_error = 10;
#[doc = "!< specified virtual capability is missing"]
pub const wurfl_error_WURFL_ERROR_CANT_LOAD_VIRTUAL_CAPABILITY_NOT_FOUND: wurfl_error = 11;
#[doc = "!< missing id in searching device"]
pub const wurfl_error_WURFL_ERROR_EMPTY_ID: wurfl_error = 12;
#[doc = "!< specified capability is missing in its group"]
pub const wurfl_error_WURFL_ERROR_CAPABILITY_GROUP_NOT_FOUND: wurfl_error = 13;
#[doc = "!< specified capability mismatch in its group"]
pub const wurfl_error_WURFL_ERROR_CAPABILITY_GROUP_MISMATCH: wurfl_error = 14;
#[doc = "!< specified device is already defined"]
pub const wurfl_error_WURFL_ERROR_DEVICE_ALREADY_DEFINED: wurfl_error = 15;
#[doc = "!< specified user agent is already defined"]
pub const wurfl_error_WURFL_ERROR_USERAGENT_ALREADY_DEFINED: wurfl_error = 16;
#[doc = "!< circular reference in device hierarchy"]
pub const wurfl_error_WURFL_ERROR_DEVICE_HIERARCHY_CIRCULAR_REFERENCE: wurfl_error = 17;
#[doc = "!< unknown error"]
pub const wurfl_error_WURFL_ERROR_UNKNOWN: wurfl_error = 18;
#[doc = "!< specified override sideloaded browser user agent configuration not valid"]
pub const wurfl_error_WURFL_ERROR_INVALID_USERAGENT_PRIORITY: wurfl_error = 19;
#[doc = "!< invalid parameter"]
pub const wurfl_error_WURFL_ERROR_INVALID_PARAMETER: wurfl_error = 20;
#[doc = "!< specified an invalid cache size, 0 or a negative value."]
pub const wurfl_error_WURFL_ERROR_INVALID_CACHE_SIZE: wurfl_error = 21;
#[doc = "!< WURFL data file is out of date or wrong - some needed device_id/capability is missing"]
pub const wurfl_error_WURFL_ERROR_XML_CONSISTENCY: wurfl_error = 22;
#[doc = "!< internal error. If this is an updater issue, please enable and check updater log using wurfl_updater_set_log_path()"]
pub const wurfl_error_WURFL_ERROR_INTERNAL: wurfl_error = 23;
#[doc = "!< the requested virtual capability has not been licensed"]
pub const wurfl_error_WURFL_ERROR_VIRTUAL_CAPABILITY_NOT_AVAILABLE: wurfl_error = 24;
pub const wurfl_error_WURFL_ERROR_MISSING_USERAGENT: wurfl_error = 25;
pub const wurfl_error_WURFL_ERROR_XML_PARSE: wurfl_error = 26;
pub const wurfl_error_WURFL_ERROR_UPDATER_INVALID_DATA_URL: wurfl_error = 27;
pub const wurfl_error_WURFL_ERROR_UPDATER_INVALID_LICENSE: wurfl_error = 28;
pub const wurfl_error_WURFL_ERROR_UPDATER_NETWORK_ERROR: wurfl_error = 29;
pub const wurfl_error_WURFL_ERROR_ENGINE_NOT_INITIALIZED: wurfl_error = 30;
pub const wurfl_error_WURFL_ERROR_UPDATER_ALREADY_RUNNING: wurfl_error = 31;
pub const wurfl_error_WURFL_ERROR_UPDATER_NOT_RUNNING: wurfl_error = 32;
pub const wurfl_error_WURFL_ERROR_UPDATER_TOO_MANY_REQUESTS: wurfl_error = 33;
pub const wurfl_error_WURFL_ERROR_UPDATER_CMDLINE_DOWNLOADER_UNAVAILABLE: wurfl_error = 34;
pub const wurfl_error_WURFL_ERROR_UPDATER_TIMEDOUT: wurfl_error = 35;
pub const wurfl_error_WURFL_ERROR_ROOT_NOT_SET: wurfl_error = 36;
pub const wurfl_error_WURFL_ERROR_WRONG_ENGINE_TARGET: wurfl_error = 37;
pub const wurfl_error_WURFL_ERROR_CANNOT_FILTER_STATIC_CAP: wurfl_error = 38;
pub const wurfl_error_WURFL_ENGINE_UNABLE_TO_ALLOCATE_MEMORY: wurfl_error = 39;
pub const wurfl_error_WURFL_ENGINE_NOT_LOADED: wurfl_error = 40;
pub const wurfl_error_WURFL_ERROR_UPDATER_CANNOT_START_THREAD: wurfl_error = 41;
pub const wurfl_error_WURFL_ERROR_ENUM_EMPTY_SET: wurfl_error = 42;
pub const wurfl_error_WURFL_ERROR_UPDATER_WRONG_DATA_FORMAT: wurfl_error = 43;
pub const wurfl_error_WURFL_ERROR_LAST: wurfl_error = 44;
pub type wurfl_error = ::std::os::raw::c_uint;
pub const wurfl_engine_target_WURFL_ENGINE_TARGET_HIGH_ACCURACY: wurfl_engine_target = 0;
pub const wurfl_engine_target_WURFL_ENGINE_TARGET_HIGH_PERFORMANCE: wurfl_engine_target = 1;
pub const wurfl_engine_target_WURFL_ENGINE_TARGET_DEFAULT: wurfl_engine_target = 2;
pub const wurfl_engine_target_WURFL_ENGINE_TARGET_FAST_DESKTOP_BROWSER_MATCH: wurfl_engine_target =
    3;
pub type wurfl_engine_target = ::std::os::raw::c_uint;
pub const wurfl_useragent_priority_WURFL_USERAGENT_PRIORITY_OVERRIDE_SIDELOADED_BROWSER_USERAGENT : wurfl_useragent_priority = 0 ;
pub const wurfl_useragent_priority_WURFL_USERAGENT_PRIORITY_USE_PLAIN_USERAGENT:
    wurfl_useragent_priority = 1;
pub const wurfl_useragent_priority_WURFL_USERAGENT_PRIORITY_INVALID: wurfl_useragent_priority = 2;
pub type wurfl_useragent_priority = ::std::os::raw::c_uint;
pub const wurfl_cache_provider_WURFL_CACHE_PROVIDER_NONE: wurfl_cache_provider = 0;
pub const wurfl_cache_provider_WURFL_CACHE_PROVIDER_LRU: wurfl_cache_provider = 1;
pub const wurfl_cache_provider_WURFL_CACHE_PROVIDER_DOUBLE_LRU: wurfl_cache_provider = 2;
pub type wurfl_cache_provider = ::std::os::raw::c_uint;
pub const wurfl_match_type_WURFL_MATCH_TYPE_EXACT: wurfl_match_type = 0;
pub const wurfl_match_type_WURFL_MATCH_TYPE_CONCLUSIVE: wurfl_match_type = 1;
pub const wurfl_match_type_WURFL_MATCH_TYPE_RECOVERY: wurfl_match_type = 2;
pub const wurfl_match_type_WURFL_MATCH_TYPE_CATCHALL: wurfl_match_type = 3;
pub const wurfl_match_type_WURFL_MATCH_TYPE_HIGHPERFORMANCE: wurfl_match_type = 4;
pub const wurfl_match_type_WURFL_MATCH_TYPE_NONE: wurfl_match_type = 5;
pub const wurfl_match_type_WURFL_MATCH_TYPE_CACHED: wurfl_match_type = 6;
pub const wurfl_match_type_WURFL_MATCH_TYPE_FAST_DESKTOP_BROWSER_MATCH: wurfl_match_type = 7;
pub type wurfl_match_type = ::std::os::raw::c_uint;
pub const wurfl_updater_frequency_WURFL_UPDATER_FREQ_DAILY: wurfl_updater_frequency = 0;
pub const wurfl_updater_frequency_WURFL_UPDATER_FREQ_WEEKLY: wurfl_updater_frequency = 1;
pub type wurfl_updater_frequency = ::std::os::raw::c_uint;
pub const wurfl_updater_data_format_WURFL_UPDATER_DATA_FORMAT_PLAIN: wurfl_updater_data_format = 0;
pub const wurfl_updater_data_format_WURFL_UPDATER_DATA_FORMAT_ZIP: wurfl_updater_data_format = 1;
pub const wurfl_updater_data_format_WURFL_UPDATER_DATA_FORMAT_GZ: wurfl_updater_data_format = 2;
pub type wurfl_updater_data_format = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _we_h {
    _unused: [u8; 0],
}
pub type wurfl_handle = *mut _we_h;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _en_t {
    _unused: [u8; 0],
}
pub type wurfl_enum_handle = *mut _en_t;
pub type wurfl_device_capability_enumerator_handle = *mut _en_t;
pub type wurfl_capability_enumerator_handle = *mut _en_t;
pub type wurfl_device_id_enumerator_handle = *mut _en_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _md_t {
    _unused: [u8; 0],
}
pub type wurfl_device_handle = *mut _md_t;
extern "C" {
    pub fn wurfl_get_api_version() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn wurfl_create() -> wurfl_handle;
}
extern "C" {
    pub fn wurfl_destroy(handle: wurfl_handle);
}
extern "C" {
    pub fn wurfl_set_log_path(
        hwurfl: wurfl_handle,
        log_path: *const ::std::os::raw::c_char,
    ) -> wurfl_error;
}
extern "C" {
    pub fn wurfl_log_print(hwurfl: wurfl_handle, msg: *mut ::std::os::raw::c_char) -> wurfl_error;
}
pub type wurfl_log_function = ::std::option::Option<
    unsafe extern "C" fn(
        log_message: *const ::std::os::raw::c_char,
        context: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    pub fn wurfl_set_log_function(
        hwurfl: wurfl_handle,
        arg1: wurfl_log_function,
        context: *mut ::std::os::raw::c_void,
    ) -> wurfl_error;
}
extern "C" {
    pub fn wurfl_get_error_message(hwurfl: wurfl_handle) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn wurfl_get_error_code(hwurfl: wurfl_handle) -> wurfl_error;
}
extern "C" {
    pub fn wurfl_has_error_message(hwurfl: wurfl_handle) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wurfl_clear_error_message(hwurfl: wurfl_handle);
}
extern "C" {
    pub fn wurfl_get_wurfl_info(hwurfl: wurfl_handle) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn wurfl_set_root(hwurfl: wurfl_handle, root: *const ::std::os::raw::c_char)
        -> wurfl_error;
}
pub const wurfl_attr_WURFL_ATTR_EXTRA_HEADERS_EXPERIMENTAL: wurfl_attr = 0;
pub type wurfl_attr = ::std::os::raw::c_uint;
extern "C" {
    pub fn wurfl_set_attr(
        hwurfl: wurfl_handle,
        attr: wurfl_attr,
        set_value: ::std::os::raw::c_int,
    ) -> wurfl_error;
}
extern "C" {
    pub fn wurfl_get_attr(
        hwurfl: wurfl_handle,
        attr: wurfl_attr,
        get_value: *mut ::std::os::raw::c_int,
    ) -> wurfl_error;
}
extern "C" {
    pub fn wurfl_add_patch(
        hwurfl: wurfl_handle,
        patch: *const ::std::os::raw::c_char,
    ) -> wurfl_error;
}
extern "C" {
    pub fn wurfl_add_patch_enabling_reload_from_memory(
        hwurfl: wurfl_handle,
        patch: *const ::std::os::raw::c_char,
    ) -> wurfl_error;
}
extern "C" {
    pub fn wurfl_add_requested_capability(
        hwurfl: wurfl_handle,
        requested_capability: *const ::std::os::raw::c_char,
    ) -> wurfl_error;
}
extern "C" {
    pub fn wurfl_set_engine_target(
        hwurfl: wurfl_handle,
        target: wurfl_engine_target,
    ) -> wurfl_error;
}
extern "C" {
    pub fn wurfl_get_engine_target(hwurfl: wurfl_handle) -> wurfl_engine_target;
}
extern "C" {
    pub fn wurfl_get_engine_target_as_string(hwurfl: wurfl_handle)
        -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn wurfl_set_useragent_priority(
        hwurfl: wurfl_handle,
        useragent_priority: wurfl_useragent_priority,
    ) -> wurfl_error;
}
extern "C" {
    pub fn wurfl_get_useragent_priority(hwurfl: wurfl_handle) -> wurfl_useragent_priority;
}
extern "C" {
    pub fn wurfl_get_useragent_priority_as_string(
        hwurfl: wurfl_handle,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn wurfl_set_cache_provider(
        hwurfl: wurfl_handle,
        cache_provider: wurfl_cache_provider,
        config: *const ::std::os::raw::c_char,
    ) -> wurfl_error;
}
extern "C" {
    pub fn wurfl_load(hwurfl: wurfl_handle) -> wurfl_error;
}
extern "C" {
    pub fn wurfl_get_last_load_time(hwurfl: wurfl_handle) -> *mut tm;
}
extern "C" {
    pub fn wurfl_get_last_load_time_as_string(
        hwurfl: wurfl_handle,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn wurfl_has_capability(
        hwurfl: wurfl_handle,
        capability: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wurfl_has_virtual_capability(
        hwurfl: wurfl_handle,
        virtual_capability: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
pub const wurfl_enum_type_WURFL_ENUM_STATIC_CAPABILITIES: wurfl_enum_type = 0;
pub const wurfl_enum_type_WURFL_ENUM_VIRTUAL_CAPABILITIES: wurfl_enum_type = 1;
pub const wurfl_enum_type_WURFL_ENUM_MANDATORY_CAPABILITIES: wurfl_enum_type = 2;
pub const wurfl_enum_type_WURFL_ENUM_WURFLID: wurfl_enum_type = 3;
pub type wurfl_enum_type = ::std::os::raw::c_uint;
extern "C" {
    pub fn wurfl_enum_create(arg1: wurfl_handle, arg2: wurfl_enum_type) -> wurfl_enum_handle;
}
extern "C" {
    pub fn wurfl_enum_get_name(handle: wurfl_enum_handle) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn wurfl_enum_is_valid(handle: wurfl_enum_handle) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wurfl_enum_move_next(handle: wurfl_enum_handle);
}
extern "C" {
    pub fn wurfl_enum_destroy(handle: wurfl_enum_handle);
}
extern "C" {
    pub fn wurfl_get_virtual_capability_enumerator(
        hwurfl: wurfl_handle,
    ) -> wurfl_capability_enumerator_handle;
}
extern "C" {
    pub fn wurfl_get_mandatory_capability_enumerator(
        hwurfl: wurfl_handle,
    ) -> wurfl_capability_enumerator_handle;
}
extern "C" {
    pub fn wurfl_get_capability_enumerator(
        hwurfl: wurfl_handle,
    ) -> wurfl_capability_enumerator_handle;
}
extern "C" {
    pub fn wurfl_capability_enumerator_get_name(
        hwurflcapabilityenumeratorhandle: wurfl_capability_enumerator_handle,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn wurfl_capability_enumerator_is_valid(
        handle: wurfl_capability_enumerator_handle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wurfl_capability_enumerator_move_next(handle: wurfl_capability_enumerator_handle);
}
extern "C" {
    pub fn wurfl_capability_enumerator_destroy(handle: wurfl_capability_enumerator_handle);
}
extern "C" {
    pub fn wurfl_get_device_id_enumerator(
        hwurfl: wurfl_handle,
    ) -> wurfl_device_id_enumerator_handle;
}
extern "C" {
    pub fn wurfl_device_id_enumerator_get_device_id(
        hwurfldeviceidenumeratorhandle: wurfl_device_id_enumerator_handle,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn wurfl_device_id_enumerator_is_valid(
        handle: wurfl_device_id_enumerator_handle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wurfl_device_id_enumerator_move_next(handle: wurfl_device_id_enumerator_handle);
}
extern "C" {
    pub fn wurfl_device_id_enumerator_destroy(handle: wurfl_device_id_enumerator_handle);
}
extern "C" {
    pub fn wurfl_device_get_capability_enumerator(
        hwurfldevice: wurfl_device_handle,
    ) -> wurfl_device_capability_enumerator_handle;
}
extern "C" {
    pub fn wurfl_device_get_virtual_capability_enumerator(
        hwurfldevice: wurfl_device_handle,
    ) -> wurfl_device_capability_enumerator_handle;
}
extern "C" {
    pub fn wurfl_device_capability_enumerator_get_name(
        arg1: wurfl_device_capability_enumerator_handle,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn wurfl_device_capability_enumerator_is_valid(
        arg1: wurfl_device_capability_enumerator_handle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wurfl_device_capability_enumerator_move_next(
        arg1: wurfl_device_capability_enumerator_handle,
    );
}
extern "C" {
    pub fn wurfl_device_capability_enumerator_destroy(
        arg1: wurfl_device_capability_enumerator_handle,
    );
}
extern "C" {
    pub fn wurfl_device_capability_enumerator_get_value(
        arg1: wurfl_device_capability_enumerator_handle,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn wurfl_device_capability_enumerator_get_value_as_int(
        hwurfldevicecapabilityenumeratorhandle: wurfl_device_capability_enumerator_handle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wurfl_device_capability_enumerator_get_value_as_bool(
        hwurfldevicecapabilityenumeratorhandle: wurfl_device_capability_enumerator_handle,
    ) -> ::std::os::raw::c_int;
}
pub type wurfl_header_retrieve_callback = ::std::option::Option<
    unsafe extern "C" fn(
        header_name: *const ::std::os::raw::c_char,
        callback_data: *const ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char,
>;
extern "C" {
    pub fn wurfl_lookup(
        hwurfl: wurfl_handle,
        header_retrieve_callback: wurfl_header_retrieve_callback,
        header_retrieve_callback_data: *const ::std::os::raw::c_void,
    ) -> wurfl_device_handle;
}
extern "C" {
    pub fn wurfl_lookup_useragent(
        hwurfl: wurfl_handle,
        useragent: *const ::std::os::raw::c_char,
    ) -> wurfl_device_handle;
}
extern "C" {
    pub fn wurfl_get_device(
        hwurfl: wurfl_handle,
        deviceid: *const ::std::os::raw::c_char,
    ) -> wurfl_device_handle;
}
extern "C" {
    pub fn wurfl_get_device_with_headers(
        hwurfl: wurfl_handle,
        deviceid: *const ::std::os::raw::c_char,
        header_retrieve_callback: wurfl_header_retrieve_callback,
        header_retrieve_callback_data: *const ::std::os::raw::c_void,
    ) -> wurfl_device_handle;
}
extern "C" {
    pub fn wurfl_device_get_id(hwurfldevice: wurfl_device_handle) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn wurfl_device_get_root_id(
        hwurfldevice: wurfl_device_handle,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn wurfl_device_get_useragent(
        hwurfldevice: wurfl_device_handle,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn wurfl_device_get_original_useragent(
        hwurfldevice: wurfl_device_handle,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn wurfl_device_get_normalized_useragent(
        hwurfldevice: wurfl_device_handle,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn wurfl_device_is_actual_device_root(
        hwurfldevice: wurfl_device_handle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wurfl_device_get_match_type(hwurfldevice: wurfl_device_handle) -> wurfl_match_type;
}
extern "C" {
    pub fn wurfl_device_get_matcher_name(
        hwurfldevice: wurfl_device_handle,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn wurfl_device_get_bucket_matcher_name(
        hwurfldevice: wurfl_device_handle,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn wurfl_device_destroy(handle: wurfl_device_handle);
}
extern "C" {
    pub fn wurfl_device_has_capability(
        hwurfldevice: wurfl_device_handle,
        capability: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wurfl_device_get_capability(
        hwurfldevice: wurfl_device_handle,
        capability: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn wurfl_device_get_capability_as_int(
        hwurfldevice: wurfl_device_handle,
        capability: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wurfl_device_get_capability_as_bool(
        hwurfldevice: wurfl_device_handle,
        capability: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wurfl_device_has_virtual_capability(
        hwurfldevice: wurfl_device_handle,
        capability: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wurfl_device_get_virtual_capability(
        hwurfldevice: wurfl_device_handle,
        capability: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn wurfl_device_get_virtual_capability_as_int(
        hwurfldevice: wurfl_device_handle,
        capability: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wurfl_device_get_virtual_capability_as_bool(
        hwurfldevice: wurfl_device_handle,
        capability: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wurfl_device_get_static_cap(
        hwdev: wurfl_device_handle,
        cap: *const ::std::os::raw::c_char,
        err: *mut wurfl_error,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn wurfl_device_get_static_cap_as_int(
        hwdev: wurfl_device_handle,
        cap: *const ::std::os::raw::c_char,
        err: *mut wurfl_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wurfl_device_get_static_cap_as_bool(
        hwdev: wurfl_device_handle,
        cap: *const ::std::os::raw::c_char,
        err: *mut wurfl_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wurfl_device_get_virtual_cap(
        hwdev: wurfl_device_handle,
        vcap: *const ::std::os::raw::c_char,
        err: *mut wurfl_error,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn wurfl_device_get_virtual_cap_as_int(
        hwdev: wurfl_device_handle,
        vcap: *const ::std::os::raw::c_char,
        err: *mut wurfl_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wurfl_device_get_virtual_cap_as_bool(
        hwdev: wurfl_device_handle,
        vcap: *const ::std::os::raw::c_char,
        err: *mut wurfl_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wurfl_updater_set_log_path(
        hwurfl: wurfl_handle,
        log_path: *const ::std::os::raw::c_char,
    ) -> wurfl_error;
}
pub type wurfl_updater_log_function = ::std::option::Option<
    unsafe extern "C" fn(
        log_message: *const ::std::os::raw::c_char,
        data: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    pub fn wurfl_updater_set_log_function(
        hwurfl: wurfl_handle,
        arg1: wurfl_updater_log_function,
        data: *mut ::std::os::raw::c_void,
    ) -> wurfl_error;
}
extern "C" {
    pub fn wurfl_updater_set_data_url(
        hwurfl: wurfl_handle,
        data_url: *const ::std::os::raw::c_char,
    ) -> wurfl_error;
}
extern "C" {
    pub fn wurfl_updater_set_data_frequency(
        hwurfl: wurfl_handle,
        freq: wurfl_updater_frequency,
    ) -> wurfl_error;
}
extern "C" {
    pub fn wurfl_updater_set_data_url_timeouts(
        hwurfl: wurfl_handle,
        connection_timeout: ::std::os::raw::c_int,
        data_transfer_timeout: ::std::os::raw::c_int,
    ) -> wurfl_error;
}
extern "C" {
    pub fn wurfl_updater_runonce(hwurfl: wurfl_handle) -> wurfl_error;
}
extern "C" {
    pub fn wurfl_updater_start(hwurfl: wurfl_handle) -> wurfl_error;
}
extern "C" {
    pub fn wurfl_updater_stop(hwurfl: wurfl_handle) -> wurfl_error;
}
extern "C" {
    pub fn wurfl_updater_reload_root(
        hwurfl: wurfl_handle,
        newroot: *const ::std::os::raw::c_char,
    ) -> wurfl_error;
}
extern "C" {
    pub fn wurfl_updater_reload_root_from_memory(
        hwurfl: wurfl_handle,
        data: *const ::std::os::raw::c_char,
        data_len: size_t,
        format: wurfl_updater_data_format,
    ) -> wurfl_error;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ih_h {
    _unused: [u8; 0],
}
pub type wurfl_important_header_handle = *mut _ih_h;
extern "C" {
    pub fn wurfl_important_header_create(arg1: wurfl_handle) -> wurfl_important_header_handle;
}
extern "C" {
    pub fn wurfl_important_header_set(
        arg1: wurfl_important_header_handle,
        name: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> wurfl_error;
}
extern "C" {
    pub fn wurfl_important_header_destroy(arg1: wurfl_important_header_handle);
}
extern "C" {
    pub fn wurfl_lookup_with_important_header(
        arg1: wurfl_handle,
        arg2: wurfl_important_header_handle,
    ) -> wurfl_device_handle;
}
extern "C" {
    pub fn wurfl_get_device_with_important_header(
        arg1: wurfl_handle,
        deviceid: *const ::std::os::raw::c_char,
        arg2: wurfl_important_header_handle,
    ) -> wurfl_device_handle;
}
extern "C" {
    pub fn wurfl_get_important_header_names() -> *mut *const ::std::os::raw::c_char;
}
pub type wurfl_important_header_enumerator_handle = *mut ::std::os::raw::c_void;
extern "C" {
    pub fn wurfl_get_important_header_enumerator(
        hwurfl: wurfl_handle,
    ) -> wurfl_important_header_enumerator_handle;
}
extern "C" {
    pub fn wurfl_important_header_enumerator_destroy(
        arg1: wurfl_important_header_enumerator_handle,
    );
}
extern "C" {
    pub fn wurfl_important_header_enumerator_get_value(
        arg1: wurfl_important_header_enumerator_handle,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn wurfl_important_header_enumerator_is_valid(
        arg1: wurfl_important_header_enumerator_handle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wurfl_important_header_enumerator_move_next(
        arg1: wurfl_important_header_enumerator_handle,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
